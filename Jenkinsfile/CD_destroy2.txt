pipeline {
    agent none

    options {
        timeout(time: 2, unit: 'HOURS')
        timestamps()
    }

    environment {
        AWS_DEFAULT_REGION = 'us-west-2'
        AWS_ACCESS_KEY_ID     = credentials('aws-access-key')
        AWS_SECRET_ACCESS_KEY = credentials('aws-secret-key')

        CLUSTER_NAME = 'devcluster'
        NAMESPACE    = 'devproject'

        DOMAIN_NAME    = 'www.cipherworld.shop'
        HOSTED_ZONE_ID = 'Z00868963MIIUG9RNPKSN'

        // MUST match VPC Name tag
        VPC_NAME_TAG = 'dev-eks-vpc'
    }

    stages {

        /* ===================== SCM ===================== */
        stage('Checkout') {
            agent { label 'slave' }
            steps {
                git branch: 'dev',
                    credentialsId: 'github',
                    url: 'https://github.com/Sooria16/knote.git'
            }
        }

        /* ===================== CONFIRM ===================== */
        stage('Destroy Confirmation') {
            agent { label 'slave' }
            steps {
                input message: '‚ö†Ô∏è DESTROY ALL AWS + EKS INFRASTRUCTURE?',
                      ok: 'DESTROY'
            }
        }

        /* ===================== AWS CHECK ===================== */
        stage('Validate AWS Access') {
            agent { label 'slave' }
            steps {
                sh 'aws sts get-caller-identity'
            }
        }

        /* ===================== CHECK EKS ===================== */
        stage('Check if EKS Exists') {
            agent { label 'slave' }
            steps {
                script {
                    def status = sh(
                        script: "aws eks describe-cluster --name ${CLUSTER_NAME} --region ${AWS_DEFAULT_REGION} >/dev/null 2>&1",
                        returnStatus: true
                    )
                    env.EKS_EXISTS = (status == 0) ? "true" : "false"
                }
            }
        }

        /* ===================== KUBECTL ===================== */
        stage('Configure kubectl') {
            agent { label 'slave' }
            when { environment name: 'EKS_EXISTS', value: 'true' }
            steps {
                sh '''
                  aws eks update-kubeconfig --region ${AWS_DEFAULT_REGION} --name ${CLUSTER_NAME}
                  kubectl config current-context
                '''
            }
        }

        /* ===================== DELETE APP ===================== */
        stage('Delete Kubernetes Resources') {
            agent { label 'slave' }
            when { environment name: 'EKS_EXISTS', value: 'true' }
            steps {
                sh '''
                  set +e
                  kubectl delete -f kube-cluster/dev/multi-tier/webcon.yaml --ignore-not-found
                  kubectl delete -f kube-cluster/dev/multi-tier/mongodb.yaml --ignore-not-found
                  kubectl delete -f kube-cluster/dev/multi-tier/pvc.yaml --ignore-not-found
                  kubectl delete -f kube-cluster/dev/multi-tier/storageclass.yaml --ignore-not-found
                  kubectl delete -f kube-cluster/dev/ns.yaml --ignore-not-found
                '''
            }
        }

        /* ===================== DELETE INGRESS ===================== */
        stage('Delete Ingress Controller') {
            agent { label 'slave' }
            when { environment name: 'EKS_EXISTS', value: 'true' }
            steps {
                sh '''
                  set +e
                  kubectl patch svc ingress-nginx-controller -n ingress-nginx \
                    -p '{"metadata":{"finalizers":[]}}' --type=merge || true
                  kubectl delete -f kube-cluster/dev/newIngressctrl.yaml --ignore-not-found
                '''
            }
        }

        /* ===================== ROUTE53 ===================== */
        stage('Delete Route53 Record') {
            agent { label 'slave' }
            steps {
                sh '''
                  set +e
                  RECORD_NAME="${DOMAIN_NAME}."

                  RECORD=$(aws route53 list-resource-record-sets \
                    --hosted-zone-id ${HOSTED_ZONE_ID} \
                    --query "ResourceRecordSets[?Name=='${RECORD_NAME}' && Type=='CNAME'] | [0]" \
                    --output json)

                  [ "$RECORD" = "null" ] && echo "No Route53 record found" && exit 0

                  aws route53 change-resource-record-sets \
                    --hosted-zone-id ${HOSTED_ZONE_ID} \
                    --change-batch "$(jq -n \
                      --arg name "$RECORD_NAME" \
                      --arg value "$(echo $RECORD | jq -r .ResourceRecords[0].Value)" \
                      --argjson ttl "$(echo $RECORD | jq -r .TTL)" \
                      '{
                        Changes: [{
                          Action: "DELETE",
                          ResourceRecordSet: {
                            Name: $name,
                            Type: "CNAME",
                            TTL: $ttl,
                            ResourceRecords: [{ Value: $value }]
                          }
                        }]
                      }'
                    )"
                '''
            }
        }

        /* ===================== DELETE EBS CSI ===================== */
        stage('Delete EBS CSI Addon') {
            agent { label 'slave' }
            when { environment name: 'EKS_EXISTS', value: 'true' }
            steps {
                sh '''
                  aws eks delete-addon \
                    --cluster-name ${CLUSTER_NAME} \
                    --addon-name aws-ebs-csi-driver \
                    --region ${AWS_DEFAULT_REGION} || true
                '''
            }
        }

        /* ===================== üî• FINAL VPC NUKE ===================== */
        stage('üî• Final VPC Dependency Nuke') {
            agent { label 'slave' }
            steps {
                sh '''
                  set +e
                  VPC_ID=$(aws ec2 describe-vpcs \
                    --filters Name=tag:Name,Values=${VPC_NAME_TAG} \
                    --query 'Vpcs[0].VpcId' \
                    --output text)

                  [ "$VPC_ID" = "None" ] && echo "No VPC found" && exit 0
                  echo "Destroying VPC: $VPC_ID"

                  aws elb describe-load-balancers \
                    --query 'LoadBalancerDescriptions[].LoadBalancerName' \
                    --output text | xargs -r aws elb delete-load-balancer || true

                  aws elbv2 describe-load-balancers \
                    --query 'LoadBalancers[].LoadBalancerArn' \
                    --output text | xargs -r aws elbv2 delete-load-balancer || true

                  sleep 90

                  aws ec2 describe-vpc-endpoints \
                    --filters Name=vpc-id,Values=$VPC_ID \
                    --query 'VpcEndpoints[].VpcEndpointId' \
                    --output text | xargs -r aws ec2 delete-vpc-endpoints || true

                  aws ec2 describe-nat-gateways \
                    --filter Name=vpc-id,Values=$VPC_ID \
                    --query 'NatGateways[].NatGatewayId' \
                    --output text | xargs -r aws ec2 delete-nat-gateway || true

                  sleep 180

                  aws ec2 describe-network-interfaces \
                    --filters Name=vpc-id,Values=$VPC_ID \
                    --query 'NetworkInterfaces[].NetworkInterfaceId' \
                    --output text | xargs -r aws ec2 delete-network-interface || true

                  aws ec2 delete-vpc --vpc-id $VPC_ID || true
                '''
            }
        }

        /* ===================== TERRAFORM ===================== */
        stage('Terraform Destroy (State Cleanup)') {
            agent { label 'slave' }
            steps {
                dir('kube-cluster/dev') {
                    sh '''
                      terraform init -no-color
                      terraform destroy \
                        -auto-approve \
                        -parallelism=5 \
                        -no-color || true
                    '''
                }
            }
        }
    }

    post {
        success { echo "üß® INFRASTRUCTURE DESTROYED SUCCESSFULLY" }
        failure { echo "‚ùå DESTROY PIPELINE FAILED" }
        always  { echo "üì¶ PIPELINE FINISHED" }
    }
}
