pipeline {
    agent none

    options {
        timeout(time: 1, unit: 'HOURS')
    }

    environment {
        // General
        BUILD = 'yes'

        // Kubernetes / App
        NAMESPACE = 'devproject'
        DOMAIN_NAME = 'www.cipherworld.shop'
        HOSTED_ZONE_ID = 'Z00868963MIIUG9RNPKSN'

        // AWS
        AWS_DEFAULT_REGION = 'us-west-2'
        AWS_ACCESS_KEY_ID     = credentials('aws-access-key')
        AWS_SECRET_ACCESS_KEY = credentials('aws-secret-key')
    }

    stages {

        /* -------------------- SCM -------------------- */
        stage('Checkout') {
            agent { label 'slave' }
            steps {
                git branch: 'dev',
                    credentialsId: 'github',
                    url: 'https://github.com/Sooria16/knote.git'
            }
        }

        /* -------------------- PRE CHECK -------------------- */
        stage('PreDeploy Check') {
            agent { label 'slave' }
            steps {
                echo "üöÄ BUILD=${env.BUILD}"
            }
        }

        stage('Deploy Approval') {
            agent { label 'slave' }
            steps {
                input message: 'Proceed with INFRA + APP deployment?',
                      ok: 'DEPLOY'
            }
        }

        /* -------------------- AWS VALIDATION -------------------- */
        stage('Test AWS Access') {
            agent { label 'slave' }
            steps {
                sh 'aws sts get-caller-identity'
            }
        }

        /* -------------------- TERRAFORM -------------------- */
        stage('Terraform Init & Plan') {
            agent { label 'slave' }
            when { environment name: 'BUILD', value: 'yes' }
            steps {
                dir('sun-kube-cluster/dev') {
                    sh '''
                        terraform init -no-color
                        terraform plan -no-color
                    '''
                }
            }
        }

        stage('Terraform Apply') {
            agent { label 'slave' }
            when { environment name: 'BUILD', value: 'yes' }
            steps {
                dir('sun-kube-cluster/dev') {
                    sh '''
                        terraform apply -auto-approve -no-color
                    '''
                }
            }
        }

        /* -------------------- EKS CONFIG -------------------- */
        stage('Configure EKS Access') {
            agent { label 'slave' }
            steps {
                sh '''
                    aws eks update-kubeconfig \
                      --region us-west-2 \
                      --name devcluster

                    kubectl config current-context
                    kubectl get nodes
                '''
            }
        }

        /* -------------------- KUBERNETES -------------------- */
        stage('Deploy Namespace, Storage & DB') {
            agent { label 'slave' }
            steps {
                sh '''
                    kubectl apply -f sun-kube-cluster/dev/ns.yaml
                    kubectl apply -f sun-kube-cluster/dev/multi-tier/storageclass.yaml
                    kubectl apply -f sun-kube-cluster/dev/multi-tier/pvc.yaml
                    kubectl apply -f sun-kube-cluster/dev/multi-tier/mongodb.yaml
                '''
            }
        }

        stage('Deploy Ingress Controller') {
            agent { label 'slave' }
            steps {
                sh '''
                    kubectl apply -f sun-kube-cluster/dev/newIngressctrl.yaml
                '''
            }
        }

        stage('Wait for LoadBalancer') {
            agent { label 'slave' }
            steps {
                sh '''
                    echo "‚è≥ Waiting for AWS LoadBalancer..."
                    for i in {1..30}; do
                      LB_DNS=$(kubectl get svc -n ingress-nginx ingress-nginx-controller \
                        -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)

                      if [ -n "$LB_DNS" ]; then
                        echo "$LB_DNS" > lb_dns.txt
                        echo "‚úÖ LB Ready: $LB_DNS"
                        exit 0
                      fi
                      sleep 10
                    done
                    echo "‚ùå LoadBalancer not ready"
                    exit 1
                '''
            }
        }

        /* -------------------- ROUTE53 UPSERT -------------------- */
        stage('Update Route53 Record') {
            agent { label 'slave' }
            steps {
                sh '''
                    LB_DNS=$(cat lb_dns.txt)

                    cat <<EOF > route53-upsert.json
{
  "Comment": "Auto update from Jenkins",
  "Changes": [{
    "Action": "UPSERT",
    "ResourceRecordSet": {
      "Name": "${DOMAIN_NAME}",
      "Type": "CNAME",
      "TTL": 300,
      "ResourceRecords": [
        { "Value": "$LB_DNS" }
      ]
    }
  }]
}
EOF

                    aws route53 change-resource-record-sets \
                      --hosted-zone-id ${HOSTED_ZONE_ID} \
                      --change-batch file://route53-upsert.json
                '''
            }
        }

        /* -------------------- APP DEPLOY -------------------- */
        stage('Deploy Web Application') {
            agent { label 'slave' }
            steps {
                sh '''
                    kubectl apply -f sun-kube-cluster/dev/multi-tier/webcon.yaml
                    kubectl rollout status deployment/frontend -n ${NAMESPACE}
                '''
            }
        }
    }

    post {
        success {
            echo "‚úÖ Application deployed successfully"
            echo "üåê URL: http://${DOMAIN_NAME}"
        }
        failure {
            echo "‚ùå Deployment failed"
        }
        always {
            echo "üì¶ Pipeline finished at ${new Date()}"
        }
    }
}
