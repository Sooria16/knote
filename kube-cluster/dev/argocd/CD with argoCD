pipeline {
    agent none

    options {
        timeout(time: 1, unit: 'HOURS')
        timestamps()
    }

    environment {
        AWS_DEFAULT_REGION = 'us-west-2'
        AWS_ACCESS_KEY_ID     = credentials('aws-access-key')
        AWS_SECRET_ACCESS_KEY = credentials('aws-secret-key')

        CLUSTER_NAME = 'devcluster'

        DOMAIN_NAME = 'www.cipherworld.shop'
        HOSTED_ZONE_ID = 'Z006951638KEXUAHFA7HX'
    }

    stages {

        /* ===================== SCM ===================== */
        stage('Checkout') {
            agent { label 'slave' }
            steps {
                git branch: 'dev',
                    credentialsId: 'github',
                    url: 'https://github.com/Sooria16/knote.git'
            }
        }

        /* ===================== AWS ===================== */
        stage('Validate AWS Access') {
            agent { label 'slave' }
            steps {
                sh 'aws sts get-caller-identity'
            }
        }

        stage('Check EKS Cluster Exists') {
            agent { label 'slave' }
            steps {
                script {
                    def rc = sh(
                        script: "aws eks describe-cluster --name ${CLUSTER_NAME} --region ${AWS_DEFAULT_REGION} >/dev/null 2>&1",
                        returnStatus: true
                    )
                    env.CLUSTER_EXISTS = (rc == 0) ? 'true' : 'false'
                    echo "EKS Cluster Exists: ${env.CLUSTER_EXISTS}"
                }
            }
        }

        /* ===================== TERRAFORM ===================== */
        stage('Terraform Init & Apply') {
            agent { label 'slave' }
            when { expression { env.CLUSTER_EXISTS == 'false' } }
            steps {
                dir('kube-cluster/dev') {
                    sh '''
                        terraform init -no-color
                        terraform apply -auto-approve -no-color
                    '''
                }
            }
        }

        /* ===================== KUBECTL ===================== */
        stage('Configure kubectl') {
            agent { label 'slave' }
            steps {
                sh '''
                    aws eks update-kubeconfig \
                      --region ${AWS_DEFAULT_REGION} \
                      --name ${CLUSTER_NAME}

                    kubectl get nodes
                '''
            }
        }

        /* ===================== EKSCTL ===================== */
        stage('Ensure eksctl Installed') {
            agent { label 'slave' }
            steps {
                sh '''
                    if ! command -v eksctl >/dev/null 2>&1; then
                      curl -sSL https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz \
                        | tar -xz -C /tmp
                      sudo mv /tmp/eksctl /usr/local/bin/
                    fi
                    eksctl version
                '''
            }
        }

        stage('Associate IAM OIDC Provider') {
            agent { label 'slave' }
            steps {
                sh '''
                    eksctl utils associate-iam-oidc-provider \
                      --cluster ${CLUSTER_NAME} \
                      --approve
                '''
            }
        }

        /* ===================== FIXED EBS CSI (IDEMPOTENT) ===================== */
        stage('Ensure EBS CSI Addon') {
            agent { label 'slave' }
            steps {
                sh '''
                    set +e

                    echo "ðŸ” Checking EBS CSI addon..."
                    aws eks describe-addon \
                      --cluster-name ${CLUSTER_NAME} \
                      --addon-name aws-ebs-csi-driver \
                      --region ${AWS_DEFAULT_REGION} >/dev/null 2>&1

                    if [ $? -eq 0 ]; then
                      echo "âœ… EBS CSI addon already exists. Skipping."
                      exit 0
                    fi

                    STACK_NAME="eksctl-${CLUSTER_NAME}-addon-aws-ebs-csi-driver"

                    echo "ðŸ” Checking CloudFormation stack..."
                    aws cloudformation describe-stacks \
                      --stack-name $STACK_NAME \
                      --region ${AWS_DEFAULT_REGION} >/dev/null 2>&1

                    if [ $? -eq 0 ]; then
                      echo "âš ï¸ CloudFormation stack exists. Skipping addon creation."
                      exit 0
                    fi

                    echo "ðŸš€ Creating EBS CSI addon..."
                    eksctl create addon \
                      --name aws-ebs-csi-driver \
                      --cluster ${CLUSTER_NAME}
                '''
            }
        }

        /* ===================== APP INFRA ===================== */
        stage('Create Namespace') {
            agent { label 'slave' }
            steps {
                sh 'kubectl apply -f kube-cluster/dev/ns.yaml'
            }
        }

        stage('Apply Storage & Database') {
            agent { label 'slave' }
            steps {
                sh '''
                    kubectl apply -f kube-cluster/dev/multi-tier/storageclass.yaml
                    kubectl apply -f kube-cluster/dev/multi-tier/pvc.yaml
                    kubectl apply -f kube-cluster/dev/multi-tier/mongodb.yaml
                '''
            }
        }

        stage('Deploy App & Ingress') {
            agent { label 'slave' }
            steps {
                sh '''
                    kubectl apply -f kube-cluster/dev/multi-tier/webcon.yaml
                    kubectl apply -f kube-cluster/dev/newIngressctrl.yaml
                '''
            }
        }

        /* ===================== ARGO CD ===================== */
        stage('Create ArgoCD Namespace') {
            agent { label 'slave' }
            steps {
                sh '''
                    kubectl create namespace argocd \
                      --dry-run=client -o yaml | kubectl apply -f -
                '''
            }
        }

        stage('Deploy ArgoCD') {
            agent { label 'slave' }
            steps {
                sh '''
                    kubectl apply -f argoserver.yaml -n argocd
                '''
            }
        }

        stage('Verify ArgoCD Pods') {
            agent { label 'slave' }
            steps {
                sh 'kubectl get pods -n argocd'
            }
        }

        stage('Get ArgoCD Admin Password') {
            agent { label 'slave' }
            steps {
                sh '''
                    echo "ðŸ” ArgoCD Admin Password:"
                    kubectl -n argocd get secret argocd-initial-admin-secret \
                      -o jsonpath="{.data.password}" | base64 -d; echo
                '''
            }
        }

        stage('Create myapp Namespace') {
            agent { label 'slave' }
            steps {
                sh '''
                    kubectl create namespace myapp \
                      --dry-run=client -o yaml | kubectl apply -f -
                '''
            }
        }

        stage('Apply ArgoCD Application') {
            agent { label 'slave' }
            steps {
                sh 'kubectl apply -f application.yaml'
            }
        }

        /* ===================== DNS ===================== */
        stage('Wait for LoadBalancer') {
            agent { label 'slave' }
            steps {
                sh '''
                    for i in {1..30}; do
                      LB_DNS=$(kubectl get svc -n ingress-nginx ingress-nginx-controller \
                        -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
                      if [ -n "$LB_DNS" ]; then
                        echo "$LB_DNS" > lb_dns.txt
                        exit 0
                      fi
                      sleep 10
                    done
                    exit 1
                '''
            }
        }

        stage('Update Route53') {
            agent { label 'slave' }
            steps {
                sh '''
                    LB_DNS=$(cat lb_dns.txt)
                    cat > route53.json <<EOF
{
  "Changes": [{
    "Action": "UPSERT",
    "ResourceRecordSet": {
      "Name": "${DOMAIN_NAME}.",
      "Type": "CNAME",
      "TTL": 300,
      "ResourceRecords": [{ "Value": "$LB_DNS" }]
    }
  }]
}
EOF
                    aws route53 change-resource-record-sets \
                      --hosted-zone-id ${HOSTED_ZONE_ID} \
                      --change-batch file://route53.json
                '''
            }
        }
    }

    post {
        success {
            echo "ðŸš€ Deployment completed successfully"
            echo "ðŸŒ URL: http://${DOMAIN_NAME}"
        }
        failure {
            echo "âŒ Pipeline failed"
        }
        always {
            echo "ðŸ“¦ Finished at ${new Date()}"
        }
    }
}
